// COCURRENCY:ALLOW TO DO MULTIPLE TASK ONE AT A TIME IN GIVEN TIME, AND PARALLELISM:DOING MULTIPLE TASK ALL AT SAME TIME

// GOURUTINES :ITS A WAY  TO ACHIEVE PARALLELISM, ITS OFTEN COMPARED WITH THREADS AS,

// THREADS
//MANAGED BY OS  ,//FIXED STACK  - 1MB

//GOROUTINES  :  //MANAGED BY GO RUNTIME: BECAUSE IN THIS MORE CONNTROL IS WITH GOLANG AND THAT'S THE REASON WHY GOLANG IS FAMOUS IN CLOUD  BECAUSE IN CLOUD ENVIRONMENT WE HAVE NO SHORTAGE OF THESE THREADS AND WE CAN TAKE ADVANTAGE OF ALL OF THEM.  ,//FLEXIBLE STACK -2KB

package main

import (
	"fmt"
	"net/http"
	"sync"
)

// USING THESE PACKAGE SYNC AND HOW THERE WAIT GROUP ARE UTILISED THAT WE CAN HAVE A BETTER RSPONSE AND RESULT ,SO WE NEED A VARIABLE WHICH IS GOINT TO BE AB WAIT GROUP AND DECLARE IT HAS GLOBAL ANS PASSING IT TO IN DIFFERENT METHODS.

//WAIT IS GROUP ISKIND OF MODIFIED AND ADVANCED STEROID  VERSION OF TIME.SLEEP OR TIME.WAIT AS SOON AS WE GO AND USE THIS WAIT GROUP WE HAVE 3 JOBS TO DONE SO THE FIRST ONE IS "ADD"  AS THE GO ROUTINE IS CREATED YOU GO  HEAD AND ADD THAT IT INOT THIS WAIT GROUP,SO THIS WILL BE RESPONSIBLE FOR MANAGEMENT :AS IT SAYS THEE IS ONE GUY WHO IS OUT THERE  AND I WILL  NOT END MY METHOD TILL TAT GUY IS BACK.
// ONCE THE GO ROUTINE IS DONE  THE ITS MY RESPONSIBILITY TO CALL FOR"DONE" AND OPTIONALLY WE USE "WAIT" WHEN THE JOB IS NOT DONE.

var signals = []string{"test"}

var wg sync.WaitGroup //POINTER
var mut sync.Mutex //POINTER

func main() {
	// fmt.Println("Welcome to gouroutines")

	/* // CALL GREATER FUNCTION
	go greeter("Hello") // here the go means just fire up the thread which is further going to responsible for exeecuting the greeter with hello but it never sai when to come back and never waited to come back the main  method exist  when all the methods are fired up so we never waited to fire up the thread to come back and print those methods so we see just printing  World
	greeter("World") */

	websiteList := []string{
		"https://lco.dev",
		"https://go.dev",
		"https://google.com",
		"https://fb.com",
		"https://github.com",
	}

	for _, web := range websiteList {
		go getStatusCode(web) // this is going to fire up the thread for each website and it will not wait for the thread to finish before moving to the next website. so it will print the status code for each website in parallel.

		wg.Add(1)
	}

	wg.Wait() //USUALLY ALWAYS GOES AT THE END OF THE MAIN FUNCTION ,BECAUSE THIS GUY THE ONLY ONE NOT ALLOWING MY MAIN METHOD TO FINISH.
	fmt.Println(signals)
}

/* func greeter(s string) {
	for i := 0; i < 6; i++ {
		// hacks for handling the situation
		time.Sleep(2 * time.Millisecond)
		fmt.Println(s)

	}
} */

func getStatusCode(endpoint string) { // this methods make request and get status code
	defer wg.Done()
	res, err := http.Get(endpoint)

	if err != nil {
		fmt.Println("Oops in endpoint")
	} else {
		mut.Lock()
		// additionally i recived the endpoint
		signals = append(signals, endpoint)
		mut.Unlock()

		fmt.Printf("%d status code for %s\n", res.StatusCode, endpoint)
	}
}

// NOTE: MUTEX IS MUTUAL EXCLUSION LOCK,ZERO VALIE FOR MUTEX IS AN UNLOCK MUTEX,ROLE OF MUTEX BASICALLY IT PROVIE A LOCK OVER A MEMORY
// READ / WRITE MUTEX :LOCK THIS MEMORY TILL THIS ONE GO ROUTINE IS WORKING  AND TILL THE TIME ITS WRITING ANYTHING THIS I WILL NOT ALLOW ANYBODY TO USE THIS MEMORY.








// OTHER TYPE OF MUTEX IS SPIN LOCK : IT IS NOT BLOCKING THE GO ROUTINE, BUT IT IS NOT THE BEST SOLUTION FOR HIGH CONCURRENCY. IT IS USED WHEN WE WANT TO HAVE A LOW LATENCY AND HIGH THROUGHPUT.

// THESE ARE THE BASIC PRINCIPLES AND THEY ARE USED TO BUILD A HIGHLY CONCURRENCY AND HIGH THROUGHPUT APPLICATIONS.

// THE GOROUTINE IS THE BASIC UNIT OF CONCURRENCY IN GOLANG. THEY ARE THE UNIT OF WORK THAT CAN BE EXECUTED IN THE GOROUTINE RUNTIME.

// WHEN YOU USE GOROUTINES YOU CAN FACILITATE THE USE OF MULTIPLE CPU CORES AND THE PROCESSING OF MULTIPLE TASKS SIMULTANEOUSLY.

// IN THE ABOVE EXAMPLE WE ARE USING THE WAIT GROUP TO WAIT FOR ALL THE GOROUTINES TO BE DONE, THIS IS A WAY TO MAKE THE MAIN FUNCTION TO WAIT FOR ALL THE GOROUTINES TO BE DONE. THIS IS USEFUL WHEN YOU HAVE A LARGE NUMBER OF GOROUTINES AND YOU WANT TO BE ABLE TO TAKE CARE OF ALL OF THEM.

// OTHER THINGS ARE : WE CAN CREATE A CHANNEL TO COMMUNICATE BETWEEN GOROUTINES AND WE CAN USE SELECT STATEMENT TO HANDLE MULTIPLE CHANNELS. WE CAN USE CHANNELS TO SEND AND RECEIVE VALUES BETWEEN GOROUTINES.

// WE CAN USE CHANNELS TO SEND AND RECEIVE VALUES BETWEEN GOROUTINES.

// SELECT STATEMENT IS USED TO SELECT THE GOROUTINE THAT WILL BE READY TO EXECUTE. SELECT STATEMENT CAN BE USED WITH CHANNELS AND TIMEOUTS.